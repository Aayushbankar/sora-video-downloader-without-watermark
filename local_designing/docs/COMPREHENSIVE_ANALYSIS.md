# Comprehensive Analysis & Optimization Guide

This document records the complete technical journey of reverse-engineering the Sora video downloader, including successful strategies, failed experiments, and performance optimization techniques.

---

## 1. The Challenge
**Objective**: Download non-watermarked videos from OpenAI's Sora platform (`sora.chatgpt.com`).
**Constraint**: The official platform does not provide a direct download link for unwatermarked content usage to the public.

---

## 2. Reverse Engineering Discovery (Success)
We analyzed `sorasave.app`, a third-party tool that successfully performs these downloads.

### Findings
The site uses a backend proxy to handle the complex extraction logic.
- **Proxy URL**: `https://api.soracdn.workers.dev` (Cloudflare Worker)
- **Mechanism**:
    1.  **Metadata Request**: `GET /api-proxy/{encoded_url}` -> Returns `post_id`.
    2.  **Download Request**: `GET /download-proxy?id={post_id}` -> Returns raw MP4 stream.

### Why It Works
This proxy acts as a "privileged" client. It likely possesses:
1.  **Trusted IP/Headers**: Being a Cloudflare Worker, it might bypass some challenges.
2.  **Session Management**: It handles the generation of SAS tokens (Shared Access Signatures) required by the underlying storage.

---

## 3. Failed Attempts (What Didn't Work)
We attempted to remove the dependency on this 3rd-party proxy to create a "native" solution. All attempts failed.

### Attempt A: Direct Browser Automation (Playwright)
- **Idea**: Use a headless browser to visit `sora.chatgpt.com`, bypass Cloudflare, and scrape the `<video>` tag.
- **Result**: **FAIL**.
- **Reason**: The site implements strict "Verify you are human" challenges. Automated headless browsers (even with stealth plugins) were detected and blocked.

### Attempt B: Direct API Access
- **Idea**: Call the internal APIs directly from Python using leaked `post_id`s.
- **Result**: **FAIL**.
- **Reason**: The internal APIs require ephemeral, signed tokens that are generated by obscure JavaScript logic (WASM) or server-side session cookies that we cannot easily replicate.

### Attempt C: Azure Storage Brute-Force
- **Idea**: Guess the underlying storage URL at `videos.openai.com/{container}/{id}.mp4`.
- **Result**: **FAIL (400 Bad Request)**.
- **Reason**: Azure Blob Storage is configured to reject anonymous requests or requests without a valid SAS token. The container names are also not public.

---

## 4. The Correct Approach (Current Solution)
The only reliable method is to **use the discovered proxy** (`api.soracdn.workers.dev`). It abstracts away the authentication and Cloudflare complexity.

**Workflow**:
1.  Client sends public Sora URL to Proxy.
2.  Proxy does the heavy lifting (Auth/Token generation).
3.  Proxy streams the clean video back to Client.

---

## 5. Performance Optimization (High Speed)
Since we are proxying traffic, speed is critical. The `src/sora_downloader.py` implementation includes several optimizations to ensure maximum throughput:

### A. Connection Pooling (`requests.Session`)
- **What**: Reuses the underlying TCP connection for multiple requests.
- **Why**: Reduces latency by avoiding repeated SSL/TLS handshakes (saving ~100-300ms per file).

### B. Concurrent Downloads
- **What**: Uses `ThreadPoolExecutor` (planned feature) or async I/O.
- **Why**: Saturates network bandwidth if downloading a playlist or gallery.

### C. Resumable Downloads (Range Headers) `Required for Large Files`
- **What**: Sends `Range: bytes={start}-` header if a partial file exists.
- **Why**: Vulnerability to network drops is minimized. If a 50MB download fails at 90%, we only download the missing 10%.

### D. Optimized Buffer Sizes
- **What**: We use a chunk size of `32KB` (or dynamic based on speed).
- **Why**: Standard `4KB` chunks cause too many syscalls (disk writes). Larger chunks increase throughput.

### E. Compression
- **What**: Accept `gzip, deflate, br` headers.
- **Why**: While MP4s are already compressed, metadata responses are text (JSON) and benefit significantly from gzip.

---

## 6. Best Practices for Usage

### For Speed
Use the Python implementation (`src/sora_downloader.py`). It is significantly faster than `curl` for batch operations because of connection reuse.

### For Simplicity
Use the Bash script (`scripts/download.sh`). It has zero dependencies (runs on any Linux/Mac) and is perfect for quick, one-off downloads.

### For CI/CD Integration
Use the minimal Python script (`examples/minimal_download.py`). It uses only the standard library, meaning you don't need to `pip install` anything in your pipeline.
